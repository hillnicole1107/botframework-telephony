# Controlling Telephony and speech specific behavior
To allow speech specific functionality, the botframework SDK has extended existing APIs and implemented a new one for recording.

## Disable barge-in
Barge-in, also called "allow interrupt", is the ability of a system to allow callers to interrupt or barge-in during voice playback by speaking or pressing a numpad key (DTMF). Telephony channel enables both forms of barge-in (speech and DTMF) by default. On barge-in, the current bot message will be stopped and any queued bot messages will be dequeued. 

Sometimes it is necessary though, due to legal or compliance requirements, to disallow barge-in on a per message basis. Telephony channel allows barge-in to be disabled for just speech barge-in, just DTMF barge-in or disabled for both.

To disable barge-in (either for speech barge-in, DTMF barge-in, or both), the activity must have an input hint value. The barge-in mode will only affect the message it is applied to, not any subsequent messages. As stated before, both speech and DTMF barge-in are enabled by default so no inputHint is needed for that case. Below are examples on how to disable only speech, only dtmf, or both forms of barge-in:

### Experimental InputHint Additions
```csharp
    public static class InputHints
    {
        public const string AcceptingInput = "acceptingInput";
        public const string IgnoringInput = "ignoringInput";
        public const string IgnoringNonSpeechInput = "ignoringNonSpeechInput";
        public const string IgnoringSpeechInput = "ignoringSpeechInput";
        public const string ExpectingInput = "expectingInput";
    }
```

### Example 1: Disable Both Speech and DTMF Barge-In
This mode ensures the entirety of the message will be played out before any user action can be taken.
```csharp
    private string SimpleConvertToSSML(string text, string voiceId, string locale)
    {
        string ssmlTemplate = @"
        <speak version='1.0' xmlns='http://www.w3.org/2001/10/synthesis' xml:lang='{2}'>
            <voice name='{1}'> {0} </voice>
        </speak>";

        return string.Format(ssmlTemplate, text, voiceId, locale);
    }

    var replyText = "The barge-in mode for this message is none, both speech and dtmf barge-in are disabled"
    await turnContext.SendActivityAsync(
        MessageFactory.Text(
            replyText,
            SimpleConvertToSSML(
                replyText,
                "Microsoft Server Speech Text to Speech Voice (en-US, JessaRUS)",
                "en-US"),
            InputHints.IgnoringInput
        ), cancellationToken);
```

_Note:_ Disabeling only DTMF or only speech barge-in is not yet fully functional. The support for these barge-in modes is expected  to land in early March 2021

### Example 2: Disable Just DTMF Barge-In
```csharp
    private string SimpleConvertToSSML(string text, string voiceId, string locale)
    {
        string ssmlTemplate = @"
        <speak version='1.0' xmlns='http://www.w3.org/2001/10/synthesis' xml:lang='{2}'>
            <voice name='{1}'> {0} </voice>
        </speak>";

        return string.Format(ssmlTemplate, text, voiceId, locale);
    }

    var replyText = "The barge-in mode for this message is speech only, only dtmf barge-in is disabled"
    await turnContext.SendActivityAsync(
        MessageFactory.Text(
            replyText,
            SimpleConvertToSSML(
                replyText,
                "Microsoft Server Speech Text to Speech Voice (en-US, JessaRUS)",
                "en-US"),
            InputHints.IgnoringNonSpeechInput
        ), cancellationToken);
```

### Example 3: Disable Just Speech Barge-In
```csharp
    private string SimpleConvertToSSML(string text, string voiceId, string locale)
    {
        string ssmlTemplate = @"
        <speak version='1.0' xmlns='http://www.w3.org/2001/10/synthesis' xml:lang='{2}'>
            <voice name='{1}'> {0} </voice>
        </speak>";

        return string.Format(ssmlTemplate, text, voiceId, locale);
    }

    var replyText = "The barge-in mode for this message is dtmf only, only speech barge-in is disabled"
    await turnContext.SendActivityAsync(
        MessageFactory.Text(
            replyText,
            SimpleConvertToSSML(
                replyText,
                "Microsoft Server Speech Text to Speech Voice (en-US, JessaRUS)",
                "en-US"),
            InputHints.IgnoringSpeechInput
        ), cancellationToken);
```
_Note:_ In the Public Preview release, the botframework SDK does not yet contain all InputHints contstants (InputHints.IgnoringSpeechInput, InputHints.IgnoringNonSpeechInput). Until support is added in the SDK, please use the strings listed in the "Experimental InputHint Additions" section.


## DTMF input

DTMF input is passed to the bot in the `Text` field of the activity object. Possible DTMF characters are digits from `0` to `9`, `*` (star) and `#` (pound). DTMF input is not localized.

Activities generated by speech and the telephone keypad are not combined. For example, saying 'fourty' and pressing &#9313; on the keypad will result in two separate activities.

It is sometimes necessary to distinguish voice from DTMF input, i.e. whether the user spoke an utterance or pressed it on the telephone keypad. 

An activity that was generated by the telephone keypad can be recognized by the presence of the DTMF entity attached to its `Entities` list. 

Example:

```csharp
protected override async Task OnMessageActivityAsync(ITurnContext<IMessageActivity> turnContext, CancellationToken cancellationToken)
{
    string response;
    if (turnContext.Activity.Entities.Any(entity => entity.Type == "DTMF"))
    {
        response = $"You have pressed DTMF button(s) {turnContext.Activity.Text}";
    }
    else
    {
        response = $"You have said {turnContext.Activity.Text}";
    }
}
```
_Note:_ In the Public Preview release, every individual key press is sent to the bot as a separate activity. The ability to "batch" multiple DTMF signals in a single activity will be added in the GA release.

## Start recording, stop recording, and attach metadata to the recording
Adapter offers “StartRecording”,“StopRecording”, and "ResumeRecording" methods, which have channel specific implementations.

StartRecording when called, starts recording the conversation and returns a recording result containing metadata about the recording.

StopRecording when called stops recording the conversation and returns a recording result containing metadata about the recording.

ResumeRecording when called, resumes recording the conversation, appending the new section of the recording to the previously started recording for this conversation, and returns a recoridng result containing metadata about the recording.

```csharp
public class RecordingResult
{
    public string RecordingId { get; set; }
    public RecordingStatus RecordingStatus { get; set; }
    public string Message { get; set; }
}

public enum RecordingStatus
{
    RecordingStarted,
    RecordingNotStarted,
    RecordingAlreadyInProgress,
    RecordingStopped
}
```

If StopRecording is never called, the recording must be stopped when the channel ends the conversation

If a recording is started for a conversation (On any storage path), recording cannot be started elsewhere. Channel should return "RecordingAlreadyInProgress" in this case, and otherwise do nothing. This will require the channel to ensure some synchronization so that no race condition is experienced by consumers of thsi API.

If StopRecording is called and there is no recording in progress, channel should return "RecordingNotStarted".

If a recording for a single conversation is stopped and started again, the recordings should be appended in storage.

Channels must return a recording id that uniquely refers to the recording at the storage path.
Channels should prefer to use conversation id as this recording id where possible.

```csharp
public class AdapterWithRecording : AdapterWithErrorHandler
{
    public AdapterWithRecording(IConfiguration configuration, ILogger<BotFrameworkHttpAdapter> logger, ConversationState conversationState = null) : base(configuration, logger, conversationState)
    {
    }

    public virtual async Task<RecordingResult> StartRecordingAsync(string StoragePath, ITurnContext turnContext, CancellationToken cancellationToken)
    {
        //Endpoint like /{conversationId}/StartRecording
        return new RecordingResult
        {
            RecordingStatus = RecordingStatus.RecordingStarted,
            Message = "Recording has started successfully."
        };
    }

    public virtual async Task<RecordingResult> StopRecordingAsync(ITurnContext turnContext, CancellationToken cancellationToken)
    {
        //Endpoint like /{conversationId}/StopRecording
        return new RecordingResult
        {
            RecordingStatus = RecordingStatus.RecordingStopped,
            Message = "Recording has stopped successfully."
        };
    }

    public virtual async Task<RecordingResult> ResumeRecordingAsync(ITurnContext turnContext, CancellationToken cancellationToken)
    {
        //Endpoint like /{conversationId}/ResumeRecording
        return new RecordingResult
        {
            RecordingStatus = RecordingStatus.RecordingStarted,
            Message = "Recording has resumed successfully."
        };
    }
}
```

Call Pattern
```csharp
protected override async Task OnMembersAddedAsync(IList<ChannelAccount> membersAdded, ITurnContext<IConversationUpdateActivity> turnContext, CancellationToken cancellationToken)
{
    foreach (var member in membersAdded)
    {
        // Greet anyone that was not the target (recipient) of this message.
        if (member.Id != turnContext.Activity.Recipient.Id)
        {
            var response = VoiceFactory.TextAndVoice($"Welcome to {CompanyName}! This call may be recorded for quality assurance purposes.");

            await turnContext.SendActivityAsync(response, cancellationToken);
            AdapterWithRecording adapterWithRecording = (AdapterWithRecording)turnContext.Adapter;

            var recordingResult = await adapterWithRecording.StartRecordingAsync("Storage1", turnContext, cancellationToken);
            if (recordingResult.RecordingStatus == RecordingStatus.RecordingNotStarted)
            {
                var recordingFailed = VoiceFactory.TextAndVoice($"Recording has failed, but your call will continue.");

                await turnContext.SendActivityAsync(recordingFailed, cancellationToken);
            }

            await Dialog.RunAsync(turnContext, ConversationState.CreateProperty<DialogState>("DialogState"), cancellationToken);
        }
    }
}
```
